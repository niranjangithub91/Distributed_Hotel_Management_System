// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: user.proto

package userpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AllTheServices_Login_FullMethodName = "/user.All_the_services/Login"
)

// AllTheServicesClient is the client API for AllTheServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AllTheServicesClient interface {
	Login(ctx context.Context, in *LoginDataSend, opts ...grpc.CallOption) (*User, error)
}

type allTheServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewAllTheServicesClient(cc grpc.ClientConnInterface) AllTheServicesClient {
	return &allTheServicesClient{cc}
}

func (c *allTheServicesClient) Login(ctx context.Context, in *LoginDataSend, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, AllTheServices_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AllTheServicesServer is the server API for AllTheServices service.
// All implementations must embed UnimplementedAllTheServicesServer
// for forward compatibility.
type AllTheServicesServer interface {
	Login(context.Context, *LoginDataSend) (*User, error)
	mustEmbedUnimplementedAllTheServicesServer()
}

// UnimplementedAllTheServicesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAllTheServicesServer struct{}

func (UnimplementedAllTheServicesServer) Login(context.Context, *LoginDataSend) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAllTheServicesServer) mustEmbedUnimplementedAllTheServicesServer() {}
func (UnimplementedAllTheServicesServer) testEmbeddedByValue()                        {}

// UnsafeAllTheServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AllTheServicesServer will
// result in compilation errors.
type UnsafeAllTheServicesServer interface {
	mustEmbedUnimplementedAllTheServicesServer()
}

func RegisterAllTheServicesServer(s grpc.ServiceRegistrar, srv AllTheServicesServer) {
	// If the following call pancis, it indicates UnimplementedAllTheServicesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AllTheServices_ServiceDesc, srv)
}

func _AllTheServices_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginDataSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllTheServicesServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllTheServices_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllTheServicesServer).Login(ctx, req.(*LoginDataSend))
	}
	return interceptor(ctx, in, info, handler)
}

// AllTheServices_ServiceDesc is the grpc.ServiceDesc for AllTheServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AllTheServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.All_the_services",
	HandlerType: (*AllTheServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _AllTheServices_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	UsermanagementService_Add_Users_FullMethodName  = "/user.Usermanagement_service/Add_Users"
	UsermanagementService_DeleteUser_FullMethodName = "/user.Usermanagement_service/Delete_user"
)

// UsermanagementServiceClient is the client API for UsermanagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsermanagementServiceClient interface {
	Add_Users(ctx context.Context, in *Send_User_Data, opts ...grpc.CallOption) (*Status, error)
	DeleteUser(ctx context.Context, in *SendDeleteUserData, opts ...grpc.CallOption) (*Status, error)
}

type usermanagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUsermanagementServiceClient(cc grpc.ClientConnInterface) UsermanagementServiceClient {
	return &usermanagementServiceClient{cc}
}

func (c *usermanagementServiceClient) Add_Users(ctx context.Context, in *Send_User_Data, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, UsermanagementService_Add_Users_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usermanagementServiceClient) DeleteUser(ctx context.Context, in *SendDeleteUserData, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, UsermanagementService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsermanagementServiceServer is the server API for UsermanagementService service.
// All implementations must embed UnimplementedUsermanagementServiceServer
// for forward compatibility.
type UsermanagementServiceServer interface {
	Add_Users(context.Context, *Send_User_Data) (*Status, error)
	DeleteUser(context.Context, *SendDeleteUserData) (*Status, error)
	mustEmbedUnimplementedUsermanagementServiceServer()
}

// UnimplementedUsermanagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUsermanagementServiceServer struct{}

func (UnimplementedUsermanagementServiceServer) Add_Users(context.Context, *Send_User_Data) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add_Users not implemented")
}
func (UnimplementedUsermanagementServiceServer) DeleteUser(context.Context, *SendDeleteUserData) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUsermanagementServiceServer) mustEmbedUnimplementedUsermanagementServiceServer() {}
func (UnimplementedUsermanagementServiceServer) testEmbeddedByValue()                               {}

// UnsafeUsermanagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsermanagementServiceServer will
// result in compilation errors.
type UnsafeUsermanagementServiceServer interface {
	mustEmbedUnimplementedUsermanagementServiceServer()
}

func RegisterUsermanagementServiceServer(s grpc.ServiceRegistrar, srv UsermanagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedUsermanagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UsermanagementService_ServiceDesc, srv)
}

func _UsermanagementService_Add_Users_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Send_User_Data)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsermanagementServiceServer).Add_Users(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsermanagementService_Add_Users_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsermanagementServiceServer).Add_Users(ctx, req.(*Send_User_Data))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsermanagementService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDeleteUserData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsermanagementServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UsermanagementService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsermanagementServiceServer).DeleteUser(ctx, req.(*SendDeleteUserData))
	}
	return interceptor(ctx, in, info, handler)
}

// UsermanagementService_ServiceDesc is the grpc.ServiceDesc for UsermanagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UsermanagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Usermanagement_service",
	HandlerType: (*UsermanagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add_Users",
			Handler:    _UsermanagementService_Add_Users_Handler,
		},
		{
			MethodName: "Delete_user",
			Handler:    _UsermanagementService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	RoommanagementService_AddRooms_FullMethodName       = "/user.Roommanagement_service/Add_rooms"
	RoommanagementService_DeleteRoom_FullMethodName     = "/user.Roommanagement_service/Delete_room"
	RoommanagementService_UpdateFeatures_FullMethodName = "/user.Roommanagement_service/UpdateFeatures"
	RoommanagementService_UpdatePrice_FullMethodName    = "/user.Roommanagement_service/UpdatePrice"
)

// RoommanagementServiceClient is the client API for RoommanagementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoommanagementServiceClient interface {
	AddRooms(ctx context.Context, in *SendRoomDetails, opts ...grpc.CallOption) (*Status, error)
	DeleteRoom(ctx context.Context, in *SendDeleteRoomDetail, opts ...grpc.CallOption) (*Status, error)
	UpdateFeatures(ctx context.Context, in *SendFeatureUpdate, opts ...grpc.CallOption) (*Status, error)
	UpdatePrice(ctx context.Context, in *SendPriceUpdate, opts ...grpc.CallOption) (*Status, error)
}

type roommanagementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoommanagementServiceClient(cc grpc.ClientConnInterface) RoommanagementServiceClient {
	return &roommanagementServiceClient{cc}
}

func (c *roommanagementServiceClient) AddRooms(ctx context.Context, in *SendRoomDetails, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, RoommanagementService_AddRooms_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roommanagementServiceClient) DeleteRoom(ctx context.Context, in *SendDeleteRoomDetail, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, RoommanagementService_DeleteRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roommanagementServiceClient) UpdateFeatures(ctx context.Context, in *SendFeatureUpdate, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, RoommanagementService_UpdateFeatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roommanagementServiceClient) UpdatePrice(ctx context.Context, in *SendPriceUpdate, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, RoommanagementService_UpdatePrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoommanagementServiceServer is the server API for RoommanagementService service.
// All implementations must embed UnimplementedRoommanagementServiceServer
// for forward compatibility.
type RoommanagementServiceServer interface {
	AddRooms(context.Context, *SendRoomDetails) (*Status, error)
	DeleteRoom(context.Context, *SendDeleteRoomDetail) (*Status, error)
	UpdateFeatures(context.Context, *SendFeatureUpdate) (*Status, error)
	UpdatePrice(context.Context, *SendPriceUpdate) (*Status, error)
	mustEmbedUnimplementedRoommanagementServiceServer()
}

// UnimplementedRoommanagementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoommanagementServiceServer struct{}

func (UnimplementedRoommanagementServiceServer) AddRooms(context.Context, *SendRoomDetails) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRooms not implemented")
}
func (UnimplementedRoommanagementServiceServer) DeleteRoom(context.Context, *SendDeleteRoomDetail) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoom not implemented")
}
func (UnimplementedRoommanagementServiceServer) UpdateFeatures(context.Context, *SendFeatureUpdate) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFeatures not implemented")
}
func (UnimplementedRoommanagementServiceServer) UpdatePrice(context.Context, *SendPriceUpdate) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrice not implemented")
}
func (UnimplementedRoommanagementServiceServer) mustEmbedUnimplementedRoommanagementServiceServer() {}
func (UnimplementedRoommanagementServiceServer) testEmbeddedByValue()                               {}

// UnsafeRoommanagementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoommanagementServiceServer will
// result in compilation errors.
type UnsafeRoommanagementServiceServer interface {
	mustEmbedUnimplementedRoommanagementServiceServer()
}

func RegisterRoommanagementServiceServer(s grpc.ServiceRegistrar, srv RoommanagementServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoommanagementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoommanagementService_ServiceDesc, srv)
}

func _RoommanagementService_AddRooms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRoomDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoommanagementServiceServer).AddRooms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoommanagementService_AddRooms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoommanagementServiceServer).AddRooms(ctx, req.(*SendRoomDetails))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoommanagementService_DeleteRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDeleteRoomDetail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoommanagementServiceServer).DeleteRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoommanagementService_DeleteRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoommanagementServiceServer).DeleteRoom(ctx, req.(*SendDeleteRoomDetail))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoommanagementService_UpdateFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendFeatureUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoommanagementServiceServer).UpdateFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoommanagementService_UpdateFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoommanagementServiceServer).UpdateFeatures(ctx, req.(*SendFeatureUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoommanagementService_UpdatePrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPriceUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoommanagementServiceServer).UpdatePrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoommanagementService_UpdatePrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoommanagementServiceServer).UpdatePrice(ctx, req.(*SendPriceUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

// RoommanagementService_ServiceDesc is the grpc.ServiceDesc for RoommanagementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoommanagementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Roommanagement_service",
	HandlerType: (*RoommanagementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add_rooms",
			Handler:    _RoommanagementService_AddRooms_Handler,
		},
		{
			MethodName: "Delete_room",
			Handler:    _RoommanagementService_DeleteRoom_Handler,
		},
		{
			MethodName: "UpdateFeatures",
			Handler:    _RoommanagementService_UpdateFeatures_Handler,
		},
		{
			MethodName: "UpdatePrice",
			Handler:    _RoommanagementService_UpdatePrice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	CustomerManagement_Add_Customer_FullMethodName = "/user.Customer_management/Add_Customer"
)

// CustomerManagementClient is the client API for CustomerManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CustomerManagementClient interface {
	Add_Customer(ctx context.Context, in *Send_CustomerDetails, opts ...grpc.CallOption) (*Status, error)
}

type customerManagementClient struct {
	cc grpc.ClientConnInterface
}

func NewCustomerManagementClient(cc grpc.ClientConnInterface) CustomerManagementClient {
	return &customerManagementClient{cc}
}

func (c *customerManagementClient) Add_Customer(ctx context.Context, in *Send_CustomerDetails, opts ...grpc.CallOption) (*Status, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Status)
	err := c.cc.Invoke(ctx, CustomerManagement_Add_Customer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomerManagementServer is the server API for CustomerManagement service.
// All implementations must embed UnimplementedCustomerManagementServer
// for forward compatibility.
type CustomerManagementServer interface {
	Add_Customer(context.Context, *Send_CustomerDetails) (*Status, error)
	mustEmbedUnimplementedCustomerManagementServer()
}

// UnimplementedCustomerManagementServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCustomerManagementServer struct{}

func (UnimplementedCustomerManagementServer) Add_Customer(context.Context, *Send_CustomerDetails) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Add_Customer not implemented")
}
func (UnimplementedCustomerManagementServer) mustEmbedUnimplementedCustomerManagementServer() {}
func (UnimplementedCustomerManagementServer) testEmbeddedByValue()                            {}

// UnsafeCustomerManagementServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CustomerManagementServer will
// result in compilation errors.
type UnsafeCustomerManagementServer interface {
	mustEmbedUnimplementedCustomerManagementServer()
}

func RegisterCustomerManagementServer(s grpc.ServiceRegistrar, srv CustomerManagementServer) {
	// If the following call pancis, it indicates UnimplementedCustomerManagementServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CustomerManagement_ServiceDesc, srv)
}

func _CustomerManagement_Add_Customer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Send_CustomerDetails)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomerManagementServer).Add_Customer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CustomerManagement_Add_Customer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomerManagementServer).Add_Customer(ctx, req.(*Send_CustomerDetails))
	}
	return interceptor(ctx, in, info, handler)
}

// CustomerManagement_ServiceDesc is the grpc.ServiceDesc for CustomerManagement service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CustomerManagement_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Customer_management",
	HandlerType: (*CustomerManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Add_Customer",
			Handler:    _CustomerManagement_Add_Customer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}

const (
	EmailVerification_Send_OTP_FullMethodName = "/user.Email_verification/Send_OTP"
)

// EmailVerificationClient is the client API for EmailVerification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmailVerificationClient interface {
	Send_OTP(ctx context.Context, in *Send_CustomerEmail, opts ...grpc.CallOption) (*Send_OTPBack, error)
}

type emailVerificationClient struct {
	cc grpc.ClientConnInterface
}

func NewEmailVerificationClient(cc grpc.ClientConnInterface) EmailVerificationClient {
	return &emailVerificationClient{cc}
}

func (c *emailVerificationClient) Send_OTP(ctx context.Context, in *Send_CustomerEmail, opts ...grpc.CallOption) (*Send_OTPBack, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Send_OTPBack)
	err := c.cc.Invoke(ctx, EmailVerification_Send_OTP_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailVerificationServer is the server API for EmailVerification service.
// All implementations must embed UnimplementedEmailVerificationServer
// for forward compatibility.
type EmailVerificationServer interface {
	Send_OTP(context.Context, *Send_CustomerEmail) (*Send_OTPBack, error)
	mustEmbedUnimplementedEmailVerificationServer()
}

// UnimplementedEmailVerificationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmailVerificationServer struct{}

func (UnimplementedEmailVerificationServer) Send_OTP(context.Context, *Send_CustomerEmail) (*Send_OTPBack, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send_OTP not implemented")
}
func (UnimplementedEmailVerificationServer) mustEmbedUnimplementedEmailVerificationServer() {}
func (UnimplementedEmailVerificationServer) testEmbeddedByValue()                           {}

// UnsafeEmailVerificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmailVerificationServer will
// result in compilation errors.
type UnsafeEmailVerificationServer interface {
	mustEmbedUnimplementedEmailVerificationServer()
}

func RegisterEmailVerificationServer(s grpc.ServiceRegistrar, srv EmailVerificationServer) {
	// If the following call pancis, it indicates UnimplementedEmailVerificationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EmailVerification_ServiceDesc, srv)
}

func _EmailVerification_Send_OTP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Send_CustomerEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailVerificationServer).Send_OTP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailVerification_Send_OTP_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailVerificationServer).Send_OTP(ctx, req.(*Send_CustomerEmail))
	}
	return interceptor(ctx, in, info, handler)
}

// EmailVerification_ServiceDesc is the grpc.ServiceDesc for EmailVerification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmailVerification_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.Email_verification",
	HandlerType: (*EmailVerificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send_OTP",
			Handler:    _EmailVerification_Send_OTP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "user.proto",
}
